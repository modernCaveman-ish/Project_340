/*~~~~~~~~~~~~~~~~~~~~~~~~Frontistirio 2~~~~~~~~~~~~~~~~~~~~~~~~*/
YACC

- Μια γεννήτρια συντακτικών αναλυτών για 
τις γλώσσες C/C++
- Μετατρέπει την περιγραφή μιας context-free γραμματικής σε ένα 
LALR συντακτικό αναλυτή γραμμένο:
    (LALR = Look-Ahead Left-to-right parse, Rightmost-derivation)
- Θα χρησιμοποιήσουμε το bison, μια 
βελτιωμένη έκδοση του yacc
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
                %{
                    Πρόλογος

                        #include <stdio.h>
                        #include “def.h”
                        void print_token_value (FILE *, int, YYSTYPE); 
                        extern int lineno;

                %}
                
                    Δηλώσεις yacc

                %%
                    Περιγραφή γραμματικής
                %%

                    Επίλογος (προαιρετικό)

                        int main(int argc, char **argv) {
                        yyparse();
                        return 0;
                        }

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
%token ΤΟΚΕΝ – Ορίζει το τερματικό σύμβολο ΤΟΚΕΝ

%union – Ορίζει ένα union με τους τύπους που μπορούν 
να πάρουν τα σύμβολα (τερματικά και μη)

%union { int intVal; char * strVal; symrec *tptr; }
δηλώνει ότι τα σύμβολα μπορούν να έχουν τύπο int, char * ή 
symrec

%token <intVal> ΤΟΚΕΝ – Ορίζει το τερματικό σύμβολο 
ΤΟΚΕΝ, με τύπο αυτό που αντιστοιχεί στο intVal πεδίο 
του union

%type <intVal> expr – Ορίζει το μη τερματικό σύμβολο 
expr με τύπο αυτό που αντιστοιχεί στο intVal πεδίο του 
union.

%start symbol – Ορίζει το αρχικό σύμβολο της 
γραμματικής

%destructor { code } symbols – Ορίζει ένα τμήμα 
κώδικα που εκτελείται για τα δοθέντα σύμβολα όταν αυτά 
σταματήσουν να χρησιμοποιούνται

%expect n – Δηλώνει ότι αναμένουμε η γραμματική μας 
να έχει n conflicts

-Αυξανόμενη προτεραιότητα από πάνω προς τα κάτω, π.χ.
    %left ADD, SUB /* + -*/ (left σημαίνει ότι έχουμε αριστερή προσεταιριστικότητα)
    %left MUL, DIV /* * / */ (right σημαίνει ότι έχουμε δεξιά προσεταιριστικότητα)
    %right EXP /* ^ */ 
    %nonassoc EQ /* == * (nonassoc σημαίνει ότι δεν υπάρχει προσεταιριστικότητα)

PARAMETROI 10/11-45

/*~~~~~~~~~~~~~~~~~~~~~~~~LEX~~~~~~~~~~~~~~~~~~~~~~~~*/

%{
    #include "parser.h"
%}

%option noyywrap
%option yylineno

id          [a_zA-Z][a-zA-Z_0-9]*
integer     [0-9]+

%%

"+"         {return '+';}
"-"         {return '-';}
"*"         {return '*';}
"/"         {return '/';}
"("         {return '(';}
")"         {return ')';}
"="         {return '=';}
[\n]+       {return '\n';}

{integer}   { yylval.intValue = atoi(yytext); return INTEGER;}
{id}        { yylval.stringValue = strdup(yytext); return ID;}

[\t\n]+       {}

.           {fprintf(stderr, "CANNOT MATCH CHARACTER %s with any rule\n", yytext);}

/*~~~~~~~~~~~~~~~~~~~~~~~~LEX~~~~~~~~~~~~~~~~~~~~~~~~*/
                      /*prologos*/

%{
    #include <stdio.h>
    int yyerror (char* yaccProvidedMessage);
    int yylex (void);

    extern int yylineno;
    extern char* yytext;
    extern FILE* yyin;
%}

%start program

%token ID INTEGER
%right '='
%left ','
%left '+' '-'
%left '*' '/'
%nonassoc UMINUS
%left '(' ')'

%%

program:            assignments expressions
                    |   /*kenos kanonas*/
                    ;

expression:         INTEGER
                    | ID
                    | expression '+' expression
                    | expression '-' expression
                    | expression '*' expression
                    | expression '/' expression
                    | '(' expression ')'
                    | '-' expression %prec UMINUS /*allagi protereotitas kanona*/
                    ;

epxr:               expression '\n' 

epxression:         expressions expr    /*dimiourgia mi kenis listas expressions*/
                    | expr
                    ;

assignment:         ID '=' expressions '\n' 

assignments:        assignments assignments
                    |   /*dimiourgia listas pou mpori na einai keni*/
                    ;


                        /*epilogos*/
int yyerror (char * yaccProvideMessage){
    fprintf(stderr, "%s: at line %d, before token: %s\n", yaccProvidedMessage, yylineno, yytext);
    fprintf(stderr, "INPUT NOT VALID\n");
}                    

int main(int argc, char** argv){
    if(argc > 1){
        if (!(yyin = fopen(argv[1], "r"))) {
            fprintf(stderr, "Cannot read file: %s\n", argv[1]);
            return 1;
        }
    }
    else
        yyin = stdin;
    yyparse();
    return 0;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
                    ENTOLES EKTELESIMOU

bison --yacc --defines --output=parser.c parser.yaccProvidedMessage

flex --outfile=scanner.c scanner.l

gcc -o calc scanner.c parser.c
/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
            Μπορούμε να παρεμβάλλουμε ανάμεσα 
            στα σύμβολα των δεξιών μερών των 
            κανόνων κάποια actions, δηλαδή c, c++ 
            κώδικα μέσα σε { }

%union {
    char* stringValue;
    int intValue;
}

%token <stringValue> ID
%token <intValue> INTEGER
%right '='
%left ','
%left '+' '-'
%left '*' '/'
%nonassoc UMINUS
%left '(' ')'

%type <intValue> expression

%destructor     { free($$); } ID

    expr: ID    { printf(“Found ID\n”); }
                | expr '+' { int a = 3; } expr { int b; }
                | /* empty */ { printf(“empty\n”); }
                ;   

expression:     INTEGER                         { $$ = $1; }
                | ID                            { $$ = lookup($1); free($1); }
                | expression '+' expression     { $$ = $1 + $3; }
                | expression '-' expression     { $$ = $1 + $3; }
                | expression '*' expression     { $$ = $1 * $3; }
                | expression '/' expression     { $$ = $1 / $3; }
                | '(' expression ')'            { $$ = $2; }
                | '-' expression %prec UMINUS   { $$ = -$2; }
                ;

expr:           expression ';' { fprintf(stdout, "Result is: %d\n", $1); }

expression:     expressions expr {;}
                | expr {;}
                ;

assignment:     ID '=' expression ';' {assign($1, $3);}
                ;

assignemtns:    assignments assignment {;}
                |
                ;

{ integer }     { yylval.intValue = atoi(yytext); return INTEGER; }
{ id }          { yylval.stringValue = strdup(yyext); return ID; }
            
Gia e3etasi

1) Erwtisi https://prnt.sc/11r821k

1. lookup kanei an dn iparxei p dn iparxei to eisagei kai einai libfunc opote anaferomaste safto
2. print kanw lookup sto print scope 0 i print einai libfucn opote anaferomaste se afti
3. function foo kanw lookup gia to foo den vriskw kati opote kanw insert einai sto scope 0 sto SymTable kai meta allazoun ta x kai y
4. to print (mpainei sto kanona tou lvalue ID) kanw lookup sto global scope 1 dn to vriskw an to vro sto 0 ok
5. to local print kanw lookup sto trexon scope na dw an kanei print.. apo ti stigmi p iparxei collision dn prost sto SymbolTable opote einai error
   (an grapsw local print = 1 dn einai ok mpori na to perasei o kanonas tou local id alla tha prepei na elegxoume tn prosvasimotita twn simvolwn)
6. ::print kanoume lookup sto scope 0 (KANEI ANAZITISI MONO EKEI STO 0 KAI DEN EISAGI POTE STO SYMBOLTABLE)
7. function sto h an dn to vrei to eisagei kai meta to a to eisagei san local argument
8. to x iparxei sto scope 0 kai to y epeidi iparxei san local argument einai error epeidi einai tis allis sinartisis
9. tha kanei lookup sto scope 1 anaferete se afto kai meta lookup sto h p iparxei kai afto kai kanei kai sto lookup p kai afto iparxei

tha pw oti kanoume lookup sto y to opoio dn iparxei to isagoume
kanw lookup sto foo to opoio dn iparxei kai to kanw insert kai epeita kanw lookup gia to x to opoio dn iparxei kai to kanw eisagwgi 
sto symtable kanw meta lookup sto x pali na doume an dn iparxei to id

2) Erwtisi Undefined kai Redefined

Undefined symbol otan exei ::y kai to y dn iparxei sto global scope me kapoio tropo
- Όταν μια μεταβλητή που χρησιμοποιείται δεν είναι 
στον πίνακα συμβόλων 
- Οι μεταβλητές ορίζονται με την πρώτη εμφάνισή τους 
(εισάγονται στον symbol table) (ok)
- Όταν ζητάμε global μεταβλητή η οποία δεν έχει οριστεί και 
άρα δεν υπάρχει στον symbol table (error) 

Redefined: an grapsoume to idio foo sto idio scope einai ok
           an grapsoume foo = 5 kai apo katw function foo einai redecleration 
           an grapsoume function (print) einai redecleration error     

3) Erwtisi i grammatiki sas ypostirizei tin ekfrasi ++(x-5); 
kai an nai pws kai an oxi gt ?

tha epsaxne mesa stn parenthesi gia arxi to opio x einai Id to opoio einai primary to opio term einai
expression, to 5 tha itan number const to opoio einai primary to opio einai expression to, kai parenthesis einai term
to opoio einai expression ara dn ginetai na to kanw 

Ean kai pws sinoptika tha isxue afto x = -(function(x, y) { return (x + y); });

Arxika anagnwrizei ena funcdef giati anagnwrise ena id kai stmt 
meta to return einai ena olokliro statement, (funcdef <- function(x, y) { return (x + y); })
ginetai apo katw pros ta panw kataligoume oti einai program
